/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "STM32G030.h"
#include "button.h"
#include "adc.h"
#include "led.h"
#include "serial.h"
#include "rtctime.h"
#include "logger.h"
#include "init.h"
#include "ws2812.h"
#include "SmartPixelStrip.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif




Button bLeft;
Button bRight;

AnalogConverter lightSensor;
Serial serial;//serial, using in logger &
Led *led;//just led
RTCTime time;//using to configure and read realtime

uint8_t flgWSTransfer = 0;

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


volatile bool flagButt { false };
volatile bool flagMinute { false };
volatile bool flagSecund { false };



void RTCIrq_Handler()
{
	if((RTC->MISR & 0x00000001) == 0x00000001){ RTC->SCR |= 0x00000001; flagMinute = 1; }
	if((RTC->MISR & 0x00000002) == 0x00000002){ RTC->SCR |= 0x00000002; flagSecund = 1; }
	led->on();
}

void DMA_2_3_Handler()
{
	stopWSDMA();
		 DMA->IFCR|=0x00000010;//DMA_IFCR_CGIF6;
}

	//Таймер для реализации протокола ws2812
	//После передачи всех данных - остановить таймер
void TIM3_Handler(void)
{
	static int counter = 0;
	if(counter>=LED_HW_LENGTH)
	{
		stopTimer3();
		//startLightSensDMA();//Запускаем канал LightSens
		flgWSTransfer = WS_TRANSFER_READY;//Передача закончена - можно передавать заново
		counter = 0;
	}
	else
		counter++;
	TIM3->SR &= ~0x0001; //Clean UIF Flag
}


void SysTick_Handler()
{

	static uint32_t milliseconds = 0;

	milliseconds++;
	bLeft.timeIncrease();
	bRight.timeIncrease();
	if((milliseconds%200) == 0)
	{
		flagButt = 1;
	}
}

void EXTI0_Handler()
{
	if(EXTI->RPR1 & 0x0001){ EXTI->RPR1 |= 0x0001; bLeft.rise();  /*LOG->DEBG("BUP rise");*/ }
	if(EXTI->RPR1 & 0x0002){ EXTI->RPR1 |= 0x0002; bRight.rise();  /*LOG->DEBG("BDN rise");*/ }
	if(EXTI->FPR1 & 0x0001){ EXTI->FPR1 |= 0x0001; bLeft.fall();  /*LOG->DEBG("BUP fall");*/ }
	if(EXTI->FPR1 & 0x0002){ EXTI->FPR1 |= 0x0002; bRight.fall();  /*LOG->DEBG("BDN fall");*/ }
}


void initializeModules()
{
	led = new Led(&(GPIOC->ODR),GPIOPIN_13, false);
		led->on();

		serial.begin();
		serial.DEBG("Starting hardware initialization...");
		serial.DEBG("RTC initialization...");

		RTCTime::TimeNDate tmdt;
		tmdt.hour = 0;
		tmdt.min = 0;
		tmdt.sec = 0;
		time.RTCInit();
		time.setTime(tmdt);

		serial.DEBG("Logger initialization...");
		LOG->setSerial(&serial);
		LOG->setTimeSource(&time);

		LOG->DEBG("Logger is on!");

		LOG->DEBG("Initialize adc...");
		lightSensor.init();
		//PA7 - ADC7 - current, PB0 - ADC_8 - 60v voltage, PA6 - ADC6 - 12v voltage
		lightSensor.initChannels(AnalogConverter::ADC_7);

		lightSensor.getDataFiltered(AnalogConverter::ADC_7);
		LOG->DEBG("Initialize button interface...");
		bLeft.init(&(GPIOA->IDR), GPIOPIN_0, 700, 530);
		bRight.init(&(GPIOA->IDR), GPIOPIN_1, 700, 530);
}

int main(void)
{
	initializeHw();
	initializeModules();
SmartPixelStrip* ledstrip = new SmartPixelStrip(32,SmartPixelStrip::WS2812);
	initializeDMA();
	initWSTimer();
	NVIC->ISER |= (1 << 10); // enable interrupt # 28 (USART2)
	NVIC->ISER |= (1 << 16); // enable interrupt # 28 (USART2)

	initWs2812Buff();
		setAllLedsBright(10);
		setLedMode(LED_ONCE);
		setAllLedsColor(500);

		LOG->DEBG("ALl ready!");
    /* Loop forever */
	for(;;)
	{
		static uint16_t ledColor { 0 };
		static uint8_t ledBright { 1 };
		static uint16_t sensorValue { 0 };
		uint8_t buttonLeftState { 0 };
		uint8_t buttonRightState { 0 };

		if(flagButt)
		{
			static uint16_t lastBrightValue { 0 };
			sensorValue = lightSensor.getDataFiltered(AnalogConverter::ADC_7);
			LOG->DEBG("Light = ", sensorValue);
			uint16_t value = WS_MAX_BRIGHT - (sensorValue/100);
			if(value<1)value = 1;
			if(value>WS_MAX_BRIGHT) value = WS_MAX_BRIGHT;
			if(value!= lastBrightValue){ setAllLedsBright(value); lastBrightValue = value; };

			flagSecund = 0;
		}

		if(flagButt)
		{
			buttonLeftState = bLeft.getState();
			buttonRightState = bRight.getState();
			flagButt = 0;
		}
		if(buttonLeftState == Button::DOUBLE)
		{
			LOG->DEBG("Left DOUBLE");
			ledColor+=100;
			if(ledColor>=WS_RGB_COLORS) ledColor = 0;
			setAllLedsColor(ledColor);

		}

		if(buttonRightState == Button::SINGLE)
				{
			LOG->DEBG("Right SINGLE");
					ledBright++;
					if(ledBright>=WS_MAX_BRIGHT) ledBright = 0;
					setAllLedsBright(ledBright);

				}

		}
}

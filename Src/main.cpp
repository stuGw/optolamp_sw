/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "STM32G030.h"
#include "button.h"
#include "adc.h"
#include "led.h"
#include "serial.h"
#include "rtctime.h"
#include "logger.h"
#include "init.h"
#include "ws2812.h"
#include "SmartPixelStrip.h"
#include "ledeffects.h"
#include "ledpairs.h"
#include "resistanceconverter.h"
#include "lightsensor5528.h"
#include "memory24xx.h"
#include "crchw.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif




Button bLeft;
Button bRight;
uint32_t* hwLA;
AnalogConverter sensorADC;
Serial serial;//serial, using in logger &
Led *led;//just led
RTCTime time;//using to configure and read realtime
CRCHw crc;
uint8_t flgWSTransfer = 0;

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


volatile bool flagButt { false };
volatile bool flagMinute { false };
volatile bool flagSecund { false };



void RTCIrq_Handler()
{
	if((RTC->MISR & 0x00000001) == 0x00000001){ RTC->SCR |= 0x00000001; flagMinute = 1; }
	if((RTC->MISR & 0x00000002) == 0x00000002){ RTC->SCR |= 0x00000002; flagSecund = 1; }
	led->on();
}

void DMA_2_3_Handler()
{
	stopWSDMA();
	//stopTimer3();
		 DMA->IFCR|=0x00000010;//DMA_IFCR_CGIF6;
}

	//Таймер для реализации протокола ws2812
	//После передачи всех данных - остановить таймер
void TIM3_Handler(void)
{
	static int counter = 0;
/*	if(counter>=1*24+5)
	{
		stopTimer3();
		//startLightSensDMA();//Запускаем канал LightSens
		flgWSTransfer = WS_TRANSFER_READY;//Передача закончена - можно передавать заново
		counter = 0;
	}
	else
		counter++;*/
	if(!(DMA->CCR2&0x0001))stopTimer3();
	if( DMA->IFCR &0x00000010)stopTimer3();//DMA_IFCR_CGIF6;)
	TIM3->SR &= ~0x0001; //Clean UIF Flag
}


void SysTick_Handler()
{

	static uint32_t milliseconds = 0;

	milliseconds++;
	bLeft.timeIncrease();
	bRight.timeIncrease();
	if((milliseconds%20) == 0)
	{
		flagButt = 1;
	}
}

void EXTI0_Handler()
{
	if(EXTI->RPR1 & 0x0002){ EXTI->RPR1 |= 0x0002; bLeft.rise();  /*LOG->DEBG("BEFFECT rise",bLeft.allCounter);*/ }
	if(EXTI->RPR1 & 0x0001){ EXTI->RPR1 |= 0x0001; bRight.rise();/* LOG->DEBG("BBRIGHT rise",bRight.allCounter);*/ }
	if(EXTI->FPR1 & 0x0002){ EXTI->FPR1 |= 0x0002; bLeft.fall();  /*LOG->DEBG("BEFFECT fall", bLeft.allCounter);*/ }
	if(EXTI->FPR1 & 0x0001){ EXTI->FPR1 |= 0x0001; bRight.fall();  /*LOG->DEBG("BBRIGHT fall", bRight.allCounter);*/ }
}


void initializeModules()
{
	led = new Led(&(GPIOC->ODR),GPIOPIN_13, false);
		led->on();

		serial.begin();
		serial.DEBG("Starting hardware initialization...");
		serial.DEBG("RTC initialization...");

		RTCTime::TimeNDate tmdt;
		tmdt.hour = 0;
		tmdt.min = 0;
		tmdt.sec = 0;
		time.RTCInit();
		time.setTime(tmdt);

		serial.DEBG("Logger initialization...");
		LOG->setSerial(&serial);
		LOG->setTimeSource(&time);

		LOG->DEBG("Logger is on!");

		LOG->DEBG("Initialize adc...");
		sensorADC.init();
		//PA7 - ADC7 - current, PB0 - ADC_8 - 60v voltage, PA6 - ADC6 - 12v voltage
		sensorADC.initChannels(AnalogConverter::ADC_7);

		sensorADC.getDataFiltered(AnalogConverter::ADC_7);
		LOG->DEBG("Initialize button interface...");
		bLeft.init(&(GPIOA->IDR), GPIOPIN_1);
		bRight.init(&(GPIOA->IDR), GPIOPIN_0);
}


struct CONFIG
{
	bool brightChanged{ 0 };
	bool colorChanged { 0 };
	bool effectChanged { 0 };
	uint8_t bright { 1 };
	bool autoBright { true };
	uint16_t colorValue { 0 };
	uint8_t currentEffect { 0 };
	bool effectMode { false };
};

bool getConfiguration(CONFIG* conf, Button *buttonR, Button *buttonL)
{
	bool changed = false;
	Button::State bRState = buttonR->getState();
	Button::State bLState = buttonL->getState();
	if(bRState == Button::DOUBLE)
	{
		conf->autoBright = !conf->autoBright;
		if(conf->autoBright) LOG->DEBG("Autobright on!"); else LOG->DEBG("Autobright off");
		changed = true;
	}

	if(bLState == Button::DOUBLE)
	{
		conf->effectMode = !conf->effectMode;
		if(conf->effectMode) LOG->DEBG("Effect mode on!"); else LOG->DEBG("Effect mode off");
		changed = true;
	}

	if(bRState == Button::SINGLE)
	{
		if(!conf->autoBright)
		{
			conf->bright+=2;
			if(conf->bright > 21) conf->bright = 1;
			conf->brightChanged = true;
			changed = true;
		}
	}

	if(bLState == Button::SINGLE)
	{
		if(conf->effectMode)
		{
			conf->currentEffect++;
			if(conf->currentEffect>10)conf->currentEffect = 1;
			conf->effectChanged = true;
		}
		else
		{
			conf->colorValue+=50;
			if(conf->colorValue>1530)conf->colorValue = 0;
			conf->colorChanged = true;
		}
		changed = true;
	}
	return changed || conf->brightChanged;
}

void configureLamp()
{

}

#pragma pack(1)
struct LampParams
{
	uint16_t color { 0 };//2
	uint8_t bright{ 0 };//3
	uint8_t autoBright { 0 };//4
	uint8_t effectNo { 0 };//5
	uint8_t effectMode { 0 };//6
	uint16_t dummy2 { 0 };//8

	uint8_t crc { 0x00 };//8
}lparams;
#pragma pack()
uint32_t paramsEEPROMAddress { 0x00 };
int main(void)
{
	Memory24xx mem;
	LightSensor5528 lightSensor(1000000, &sensorADC, AnalogConverter::ADC_7);
	CONFIG lampConfiguration;
	ResistanceConverter RConverter;
	SmartPixelStrip* ledstrip = new SmartPixelStrip(32,SmartPixelStrip::WS2812, SmartPixelStrip::ONCE_MODE, startWsTransfer);
	LedPairs pairs(ledstrip);
	hwLA = ledstrip->getHwAdress();
	initializeHw();
	initializeModules();
	uint32_t* address;

	mem.setInterfaceRead(readI2C1);
	mem.setInterfaceWrite(writeI2C1);
	i2cFindDevices();
	mem.setMemoryParams(512, 0xA0);
	LOG->DEBG("Initialize crc module...");
	crc.init(0x00000000, CRCHw::POLYSIZE_8, 0x31, true, CRCHw::BY_WORD);

	initializeDMA(address, ledstrip->hwSize());
	initWSTimer();



	NVIC->ISER |= (1 << 10); // enable interrupt # 28 (USART2)
	NVIC->ISER |= (1 << 16); // enable interrupt # 28 (USART2)



	setLedMode(LED_ONCE);

#define I2C_NO_ERR 0
#define I2C_NO_DEVICE -1
#define I2C_TIMEOUT -2
#define I2C_BUSY -3
#define I2C_ARLO -4
#define I2C_BUSERR -5


		mem.readArray(reinterpret_cast<uint8_t*>(&lparams), sizeof(LampParams), paramsEEPROMAddress);
			uint8_t calculatedCrc = crc.calcCRC(reinterpret_cast<uint8_t*>(&lparams), sizeof(LampParams)-1);
			if(lparams.crc!= calculatedCrc)
			{
				///motoMinsMem.motoMinutes = 0;
				//motoMinsMem.crc = crc->calcCRC(reinterpret_cast<uint8_t*>(&motoMinsMem), sizeof(MotoMinsMemHeader)-1);
				LOG->DEBG("Error reading from mem! set 0!");
				lampConfiguration.autoBright = true;
				lampConfiguration.bright = 1;
				lampConfiguration.colorValue = 0;
				lampConfiguration.currentEffect = 1;
				lampConfiguration.effectMode = 0;

				//mem.writeArray(motoMinsAddress, reinterpret_cast<uint8_t*>(&motoMinsMem), sizeof(MotoMinsMemHeader));
			}
			else
			{
				LOG->DEBG("From memory:");
				LOG->DEBG("AutoBright: ", lparams.autoBright);
				LOG->DEBG("Bright value: ", lparams.bright);
				LOG->DEBG("Color: ", lparams.color);
				LOG->DEBG("Effect on: ", lparams.effectMode);
				LOG->DEBG("EffetNo: ", lparams.effectNo);
				lampConfiguration.autoBright = lparams.autoBright;
				lampConfiguration.bright = lparams.bright;
				lampConfiguration.colorValue = lparams.color;
				lampConfiguration.currentEffect = lparams.effectNo;
				lampConfiguration.effectMode = lparams.effectMode;
			}








		pairs.setPair(0, 0, 10);
		pairs.setPair(1, 1, 15);
		pairs.setPair(2, 2, 17);
		pairs.setPair(3, 3, 19);

		pairs.setPair(4, 4, 23);
		pairs.setPair(5, 5, 27);
		pairs.setPair(6, 6, 26);
		pairs.setPair(7, 7, 21);

		pairs.setPair(8, 8, 16);
		pairs.setPair(9, 9, 25);
		pairs.setPair(10, 11, 28);
		pairs.setPair(11, 12, 22);

		pairs.setPair(12, 13, 31);
		pairs.setPair(13, 14, 24);
		pairs.setPair(14, 18, 30);
		pairs.setPair(15, 20, 29);

		pairs.getPair(0)->setBright(21);
		pairs.getPair(0)->setColor(255,0,0);
		pairs.getPair(0)->refresh();

		pairs.getPair(1)->setBright(21);
		pairs.getPair(1)->setColor(0,255,0);
		pairs.getPair(1)->refresh();

		pairs.getPair(2)->setBright(21);
		pairs.getPair(2)->setColor(0,0,255);
		pairs.getPair(2)->refresh();

		pairs.getPair(3)->setBright(21);
		pairs.getPair(3)->setColor(255,255,0);
		pairs.getPair(3)->refresh();

		pairs.setBright(17);

		pairs.getPair(0)->setColor(255, 0, 0,  0, 128, 0);
		pairs.getPair(1)->setColor(0, 255, 0,  0, 128, 0);
		pairs.getPair(2)->setColor(0, 0, 255,  0, 128, 0);
		pairs.getPair(3)->setColor(0, 0, 255,  0, 255, 0);
		pairs.getPair(4)->setColor(255, 0, 0,  255, 0, 0);
		pairs.getPair(5)->setColor(0, 0, 255,  255, 0, 0);
		pairs.getPair(6)->setColor(0, 255, 0,  255, 0, 0);
		pairs.getPair(7)->setColor(0, 0, 255,  0, 0, 255);
		pairs.getPair(8)->setColor(255, 0, 0,  0, 0, 255);
		pairs.getPair(9)->setColor(0, 255, 0,  0, 0, 255);
		pairs.getPair(10)->setColor(255, 0, 0,  255, 0, 0);
		pairs.getPair(11)->setColor(0, 0, 255,  0, 255, 255);
		pairs.getPair(12)->setColor(255, 0, 0,  255, 255, 0);
		pairs.getPair(13)->setColor(0, 0, 255,  0, 0, 255);
		pairs.getPair(14)->setColor(255, 0, 0,  0, 128, 233);
		pairs.getPair(15)->setColor(0, 255, 0,  0, 128, 0);



		ledstrip->refresh();


		LedEffects ledEffect(&pairs);
		ledEffect.setSpeed(2500);


		if(lampConfiguration.effectMode)
		{
			ledEffect.setEffect(static_cast<LedEffects::Effects>(lampConfiguration.currentEffect));
			ledEffect.setEffectBright(lampConfiguration.bright);
		}
		else
		{
			ledstrip->setBright(lampConfiguration.bright);
			ledstrip->setColor(lampConfiguration.colorValue);
		}


	//	startWsTransfer();
		LOG->DEBG("ALl ready!");
    /* Loop forever */
	for(;;)
	{
		static uint16_t ledColor { 0 };
		static uint8_t ledBright { 1 };
		static uint16_t sensorValue { 0 };
		static int16_t autoBrightValue { 0 };
		static int16_t lastAutoBrightValue { 0 };
		bool lightChanged { true };
		uint8_t buttonLeftState { 0 };
		uint8_t buttonRightState { 0 };


		lampConfiguration.brightChanged = false;

		if(flagButt)
		{

			autoBrightValue = lightSensor.getValue();//WS_MAX_BRIGHT - (sensorValue/100);

			if(autoBrightValue<1)
			{
				lightChanged = false;
			}
			else
			{
				if(lampConfiguration.autoBright)
				{
					lampConfiguration.bright = autoBrightValue;
					lampConfiguration.brightChanged = true;
				}

				LOG->DEBG("AUTOBRIGHT = ", autoBrightValue);
			}

			flagSecund = 0;

			if(lampConfiguration.effectMode)ledEffect.play();

			flagButt = 0;
		}

		if(getConfiguration(&lampConfiguration,&bRight, &bLeft))
		{

			if(lampConfiguration.brightChanged)
			{
				if(lampConfiguration.effectMode)ledEffect.setEffectBright(lampConfiguration.bright); else { ledstrip->setBright(lampConfiguration.bright); ledstrip->refresh(); };
				lampConfiguration.brightChanged = false;
				LOG->DEBG("Bright changed! - ", lampConfiguration.bright);
			}


			//color/effect
			if(lampConfiguration.colorChanged)
			{
				ledstrip->setColor(lampConfiguration.colorValue);
				ledstrip->refresh();
				lampConfiguration.colorChanged = false;
				LOG->DEBG("Color changed! - ", lampConfiguration.colorValue);
				lparams.color = lampConfiguration.colorValue;
				lparams.crc = crc.calcCRC(reinterpret_cast<uint8_t*>(&lparams), sizeof(LampParams)-1);
							mem.writeArray(paramsEEPROMAddress, reinterpret_cast<uint8_t*>(&lparams), sizeof(LampParams));
			}

			if(lampConfiguration.effectChanged)
			{
				ledEffect.setEffect((LedEffects::Effects)lampConfiguration.currentEffect);
				lampConfiguration.effectChanged = false;
				LOG->DEBG("Effect changed! - ", lampConfiguration.currentEffect);
			}


		}
	}
}

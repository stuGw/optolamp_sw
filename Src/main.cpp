/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "STM32G030.h"
#include "button.h"
#include "adc.h"
#include "led.h"
#include "serial.h"
#include "rtctime.h"
#include "logger.h"
#include "init.h"
#include "ws2812.h"
#include "SmartPixelStrip.h"
#include "ledeffects.h"
#include "ledpairs.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif




Button bLeft;
Button bRight;
uint32_t* hwLA;
AnalogConverter lightSensor;
Serial serial;//serial, using in logger &
Led *led;//just led
RTCTime time;//using to configure and read realtime

uint8_t flgWSTransfer = 0;

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


volatile bool flagButt { false };
volatile bool flagMinute { false };
volatile bool flagSecund { false };



void RTCIrq_Handler()
{
	if((RTC->MISR & 0x00000001) == 0x00000001){ RTC->SCR |= 0x00000001; flagMinute = 1; }
	if((RTC->MISR & 0x00000002) == 0x00000002){ RTC->SCR |= 0x00000002; flagSecund = 1; }
	led->on();
}

void DMA_2_3_Handler()
{
	stopWSDMA();
	//stopTimer3();
		 DMA->IFCR|=0x00000010;//DMA_IFCR_CGIF6;
}

	//Таймер для реализации протокола ws2812
	//После передачи всех данных - остановить таймер
void TIM3_Handler(void)
{
	static int counter = 0;
/*	if(counter>=1*24+5)
	{
		stopTimer3();
		//startLightSensDMA();//Запускаем канал LightSens
		flgWSTransfer = WS_TRANSFER_READY;//Передача закончена - можно передавать заново
		counter = 0;
	}
	else
		counter++;*/
	if(!(DMA->CCR2&0x0001))stopTimer3();
	if( DMA->IFCR &0x00000010)stopTimer3();//DMA_IFCR_CGIF6;)
	TIM3->SR &= ~0x0001; //Clean UIF Flag
}


void SysTick_Handler()
{

	static uint32_t milliseconds = 0;

	milliseconds++;
	bLeft.timeIncrease();
	bRight.timeIncrease();
	if((milliseconds%20) == 0)
	{
		flagButt = 1;
	}
}

void EXTI0_Handler()
{
	if(EXTI->RPR1 & 0x0001){ EXTI->RPR1 |= 0x0001; bLeft.rise();  /*LOG->DEBG("BUP rise");*/ }
	if(EXTI->RPR1 & 0x0002){ EXTI->RPR1 |= 0x0002; bRight.rise();  /*LOG->DEBG("BDN rise");*/ }
	if(EXTI->FPR1 & 0x0001){ EXTI->FPR1 |= 0x0001; bLeft.fall();  /*LOG->DEBG("BUP fall");*/ }
	if(EXTI->FPR1 & 0x0002){ EXTI->FPR1 |= 0x0002; bRight.fall();  /*LOG->DEBG("BDN fall");*/ }
}


void initializeModules()
{
	led = new Led(&(GPIOC->ODR),GPIOPIN_13, false);
		led->on();

		serial.begin();
		serial.DEBG("Starting hardware initialization...");
		serial.DEBG("RTC initialization...");

		RTCTime::TimeNDate tmdt;
		tmdt.hour = 0;
		tmdt.min = 0;
		tmdt.sec = 0;
		time.RTCInit();
		time.setTime(tmdt);

		serial.DEBG("Logger initialization...");
		LOG->setSerial(&serial);
		LOG->setTimeSource(&time);

		LOG->DEBG("Logger is on!");

		LOG->DEBG("Initialize adc...");
		lightSensor.init();
		//PA7 - ADC7 - current, PB0 - ADC_8 - 60v voltage, PA6 - ADC6 - 12v voltage
		lightSensor.initChannels(AnalogConverter::ADC_7);

		lightSensor.getDataFiltered(AnalogConverter::ADC_7);
		LOG->DEBG("Initialize button interface...");
		bLeft.init(&(GPIOA->IDR), GPIOPIN_0, 700, 530);
		bRight.init(&(GPIOA->IDR), GPIOPIN_1, 700, 530);
}

int main(void)
{

	SmartPixelStrip* ledstrip = new SmartPixelStrip(8,SmartPixelStrip::WS2812, SmartPixelStrip::ONCE_MODE, startWsTransfer);
	hwLA = ledstrip->getHwAdress();
	initializeHw();
	initializeModules();
	uint32_t* address;

	initializeDMA(address, ledstrip->hwSize());

	initWSTimer();
	NVIC->ISER |= (1 << 10); // enable interrupt # 28 (USART2)
	NVIC->ISER |= (1 << 16); // enable interrupt # 28 (USART2)

//	initWs2812Buff();
		//setAllLedsBright(10);
		setLedMode(LED_ONCE);
	//	setAllLedsColor(500);


		ledstrip->getLed(0)->setGreen(1);
		ledstrip->getLed(0)->setBright(21);



		ledstrip->getLed(1)->setRed(2);
		ledstrip->getLed(1)->setBright(21);


		ledstrip->getLed(2)->setBlue(3);
		ledstrip->getLed(2)->setBright(21);


		ledstrip->getLed(3)->setGreen(4);
		ledstrip->getLed(3)->setRed(255);
		ledstrip->getLed(3)->setBright(21);


		ledstrip->getLed(4)->setGreen(5);
		ledstrip->getLed(4)->setBlue(255);
		ledstrip->getLed(4)->setBright(21);



		LedPairs pairs(ledstrip);

		pairs.setPair(0,0, 2);
		pairs.setPair(1,1, 4);
		pairs.setPair(2,3, 6);
		pairs.setPair(3,5,7);


		pairs.getPair(0)->setBright(21);
		pairs.getPair(0)->setColor(255,0,0);
		pairs.getPair(0)->refresh();

		pairs.getPair(1)->setBright(21);
		pairs.getPair(1)->setColor(0,255,0);
		pairs.getPair(1)->refresh();

		pairs.getPair(2)->setBright(21);
		pairs.getPair(2)->setColor(0,0,255);
		pairs.getPair(2)->refresh();

		pairs.getPair(3)->setBright(21);
		pairs.getPair(3)->setColor(255,255,0);
		pairs.getPair(3)->refresh();

//	ledstrip->setBright(value);
		ledstrip->refresh();

		LedEffects ledEffect(ledstrip);
		//LedEffects ledEffect(&pairs);
		ledEffect.setSpeed(2500);

		//ledEffect.setRainbowEachPairCoefficient(350);
		ledEffect.setEffect(LedEffects::RUN_PIXELS_SOFT);

	//	startWsTransfer();
		LOG->DEBG("ALl ready!");
    /* Loop forever */
	for(;;)
	{
		static uint16_t ledColor { 0 };
		static uint8_t ledBright { 1 };
		static uint16_t sensorValue { 0 };
		uint8_t buttonLeftState { 0 };
		uint8_t buttonRightState { 0 };

		if(flagButt)
		{
			static uint16_t lastBrightValue { 0 };
			sensorValue = lightSensor.getDataFiltered(AnalogConverter::ADC_7);
			LOG->DEBG("Light = ", sensorValue);
			uint16_t value = WS_MAX_BRIGHT - (sensorValue/100);
			if(value<1)value = 1;
			if(value>WS_MAX_BRIGHT) value = WS_MAX_BRIGHT;
			if(value!= lastBrightValue){  lastBrightValue = value; ledEffect.setEffectBright(value);};

			flagSecund = 0;
			ledEffect.play();
		}

		if(flagButt)
		{
			buttonLeftState = bLeft.getState();
			buttonRightState = bRight.getState();
			flagButt = 0;
		}
		if(buttonLeftState == Button::DOUBLE)
		{
			LOG->DEBG("Left DOUBLE");
static uint16_t color { 0 };
			color +=50;
if(color>1500) color = 0;
			ledstrip->setColor(color);
			ledstrip->refresh();
		}

		if(buttonRightState == Button::SINGLE)
				{
			LOG->DEBG("Right SINGLE");
					ledBright++;
					if(ledBright>=WS_MAX_BRIGHT) ledBright = 0;
					//ledstrip->setBright(ledBright);
					//	ledstrip->refresh();
					ledEffect.setEffectBright(ledBright);

				}

		}
}
